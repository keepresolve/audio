因为 tab、空格以及格式问题，造成合代码有时候不太容易法看出到底改动在哪。这个统一解决。

有几个问题要先解决:

1. 所有代码都设置 **indent using space** 且统一设置成 4 spaces，vscode 设置里 `diffEditor.ignoreTrimWhitespace`这项要 false，不然从两个空格改到 4 个空格，vscode 不显示差异。这三个设置放到git里，保证大家一致

2. 发现 package.json 也可以设置 4 个空格, 所以我们所有文件都用 4 个空格

3. vscode 自带 format document 和 [Beautify](https://marketplace.visualstudio.com/items?itemName=HookyQR.beautify) 做的调整有些不同，如果开启 Beautify，format document 就会用 Beautify 的格式

4. Beautify 和 [Prettier](https://prettier.io/) 两个格式化工具只能选其一，不能都用，不然会冲突。关于他们[差异](https://github.com/HookyQR/VSCodeBeautify/issues/201)参见

5. 希望 formatter 除了能控制 tab 空格，还能统一单引号，双引号问题,；最好能一次处理多个文件，基于这几条选定 Prettier。package.json 要用双引号，js 代码都改单引号

6. vscode 还没发一次性 format 所有文件, 参见这几个讨论 [1](https://github.com/Microsoft/vscode/issues/29403), [2](https://github.com/Microsoft/vscode/issues/38279) 但通过 Prettier 命令行工具可以一次格式化多个文件，这点也比 Beautify 强。


```shell
.
├── Dockerfile
├── LICENSE
├── README.md
├── favicon.ico
├── gen_wptest
│   ├── index.html
├── gulpfile.js
├── jsconfig.json
├── package.json
├── resources
│   ├── css
│   │   ├── font
│   │   │   └── font_792726_wd5lzuxvvh.woff
│   │   └── phone.scss
│   └── index.html
├── spec
│   ├── test.events.js
│   ├── test.js
│   └── webpack.config.js
├── src
│   ├── lib
│   │   ├── Logger.js
│   │   ├── getLoginInfo.js
│   │   ├── index.js
│   │   ├── province.json
│   │   └── xmljs.js
│   └── ui
│       ├── html.js
│       ├── index.js
│       └── phone.js
│── webpack.config.js
│── .babelrc
│── .gitignore
│── .npmignore
```



7. Prettier 设置[自动分号插入 ASI](http://wiki.jikexueyuan.com/project/javascript-garden/core/semicolon.html)，它会对前置括号自动插入分号（ui/index.js）; 关于[ASI 可以参考](https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi)
8. 
自动插入分号机制 ASI 大家要熟悉, 其实只有[下面5个情况](https://zhuanlan.zhihu.com/p/22998282)是没有自动插入分号会带来问题，需要注意，尤其后面两个情况 


```javascript
   //1. treated as plus operation
   a = b
   +a

   //2. treated as minus operation
   a = b
   -a

   //3. treated as division operation
   a = b
   /something/.test(a)

   //4. treated as function invocation
   a = b
   (function () {})()

   //5. treated as property access
   a = b
   [1, 2, 3].forEach() 

No ASI:
    var foo = "bar"
    [ "red", "green" ].foreach(function(c) { console.log(c) })
No semicolon is inserted. Instead, the beginning of the second line is interpreted as an index for the string "bar"; the comma is allowed due to the comma operator (which evaluates both its left-hand side and its right-hand side and returns its right-hand side).

//更复杂的[]情况

a = function() {

}
[1,2,3].forEach(function(item) {

});

//It will be interpreted as following,  but why is this valid at all?

a = function() {
}[1,2,3].forEach(function(item) {

});

function(){}[1, 2, 3] is evaluated like this: The [] are a property accessor, and functions are objects. What's inside the [] uses the comma operator, which is one of JS's more unusual operators: It evaluates both its left-hand and right-hand operands, and results in the value the right-hand operand yielded. So [1, 2, 3] is effectively [3]. So that's function(){}[3] -- reading the 3 property from the function. Then the expression goes on to try to use the forEach property of that as a function. It fails at runtime, but it's syntactically correct.
```

ASI 文章参考 [1](http://2ality.com/2011/05/semicolon-insertion.html) , [2](https://stackoverflow.com/questions/52243003/why-no-automatic-semicolon-insertionasi-for-square-bracket-at-the-new-line) 

目前看Prettier 配合 ASI 使用就 有一种情况要小心，`return {` [必须在同一行](https://coderwall.com/p/j4ub4a/put-your-opening-braces-on-the-same-line-in-js) 

演示代码加在 `test.events.js` 已提交

